.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Podwrapper::Man 1.52.0 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "guestfs-performance 1"
.TH guestfs-performance 1 2024-01-05 libguestfs-1.52.0 "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH НАЗВА
.IX Header "НАЗВА"
guestfs-performance — керування libguestfs з метою отримання найкращої швидкодії
.SH ОПИС
.IX Header "ОПИС"
Цю сторінку присвячено питанням отримання найліпшої швидкодії libguestfs, особливо у випадках, коли ви хочете використовувати libguestfs для керування тисячами віртуальних машин або образів дисків.
.PP
Наведені рекомендації стосуються трьох основних областей. Libguestfs запускає базову систему (невеличкий дистрибутив Linux) у qemu/KVM. Першими двома областями є мінімізація часу запуску базової системи та кількості запусків базової системи. Третьою областю є скорочення часу, потрібного на інспектування віртуальних машин.
.SH "БАЗОВІ ВИМІРИ"
.IX Header "БАЗОВІ ВИМІРИ"
Перш ніж вносити зміни до способів використання libguestfs, виконайте базові виміри.
.SS "База: запуск базової системи"
.IX Subsection "База: запуск базової системи"
На незавантаженій машині час, який потрібне для запуску базової системи:
.PP
.Vb 1
\& time guestfish \-a /dev/null run
.Ve
.PP
Віддайте цю команду декілька разів послідовно і відкиньте результати перших декількох запусків, щоб виміряти типовий випадок із «гарячим кешем».
.PP
\&\fIПримітка для розробників:\fR у <https://github.com/libguestfs/libguestfs\-analysis\-tools> можна знайти програму із назвою \fIboot-benchmark\fR, яка виконує те саме, але виконує декілька запусків і виводить математичне сподівання та стандартне відхилення.
.PP
\fIПояснення\fR
.IX Subsection "Пояснення"
.PP
Наведена вище команда guestfish запускає базову систему libguestfs для порожнього диска, а потім одразу вимикає її. Під час першого виконання команди програма створить базову систему і виконає її кешування (зазвичай, у \fI/var/tmp/.guestfs\-*\fR). Під час наступних запусків програма просто повторно використовуватиме кешовану базову систему.
.PP
\fIОчікувані результати\fR
.IX Subsection "Очікувані результати"
.PP
Слід очікувати значень тривалості виконання дії, менших за 6 секунд. Якщо для ненавантаженої машини ви спостерігаєте значення тривалості, яке є вищим за вказане, вам слід ознайомитися із вмістом розділу "БОРОТЬБА ІЗ ПРОБЛЕМАМИ ЗІ ШВИДКОДІЄЮ", наведеного нижче.
.SS "База: виконання інспектування гостьової системи"
.IX Subsection "База: виконання інспектування гостьової системи"
Для цього тесту вам потрібна буде ненавантажена машина і принаймні одна справжня гостьова система або образ диска. Якщо ви плануєте використовувати libguestfs лише для гостьових систем X (наприклад, X = Windows), тоді у цьому тесті варто використати саме гостьову систему X. Якщо ж ви плануєте використовувати libguestfs для різних гостьових систем, скористайтеся у цьому тесті різними гостьовими системами.
.PP
Визначте тривалість інспектування і монтування дисків гостьової системи. Скористайтеся першою з команд, якщо ви використовуватимете образи дисків, і другою із команд, якщо ви використовуватимете libvirt.
.PP
.Vb 1
\& time guestfish \-\-ro \-a диск.img \-i exit
\&
\& time guestfish \-\-ro \-d НазваГостьовоїСистеми \-i exit
.Ve
.PP
Віддайте цю команду декілька разів послідовно і відкиньте результати перших декількох запусків, щоб виміряти типовий випадок із «гарячим кешем».
.PP
\fIПояснення\fR
.IX Subsection "Пояснення"
.PP
Ця команда запускає базову систему libguestfs для іменованого образу диска або гостьової системи libvirt, виконує її інспектування за допомогою libguestfs (див. "ІНСПЕКТУВАННЯ" in \fBguestfs\fR\|(3)), монтує диски гостьової системи, а потім відкидає усі ці результати і завершує роботу.
.PP
Під час першого виконання команди програма створить базову систему і виконає її кешування (зазвичай, у \fI/var/tmp/.guestfs\-*\fR). Під час наступних запусків програма просто повторно використовуватиме кешовану базову систему.
.PP
\fIОчікувані результати\fR
.IX Subsection "Очікувані результати"
.PP
Слід очікувати на тривалість виконання, яка на ≤ 5 секунд перевищує виміряну у першому базовому тесті вище. (Наприклад, якщо перший базовий тест було виконано за 5 секунд, цей тест має виконуватися за ≤ 10 секунд.)
.SH "ДОКЛАДНІШЕ ПРО БАЗОВУ СИСТЕМУ ТА ПРО ТЕ, КОЛИ ЇЇ ЗБИРАЮТЬ ТА КОЛИ ВОНА ПОТРАПЛЯЄ ДО КЕШУ"
.IX Header "ДОКЛАДНІШЕ ПРО БАЗОВУ СИСТЕМУ ТА ПРО ТЕ, КОЛИ ЇЇ ЗБИРАЮТЬ ТА КОЛИ ВОНА ПОТРАПЛЯЄ ДО КЕШУ"
Під час першої спроби скористатися libguestfs бібліотека збирає і надсилає до кешу базову систему. Зазвичай, така базова система має адресу \fI/var/tmp/.guestfs\-*\fR, якщо вами не було встановлено значень для змінних середовища \f(CW$TMPDIR\fR або \f(CW$LIBGUESTFS_CACHEDIR\fR. Якщо було встановлено такі значення, базова система зберігатиметься у відповідному тимчасовому каталозі.
.PP
Щоб дізнатися більше про побудову базової системи, див. "БАЗОВІ СИСТЕМИ SUPERMIN" in \fBsupermin\fR\|(1).
.PP
Під час кожного запуску libguestfs намагається визначити, чи не було змінено якість файли основної системи, які використовуються базовою системою. Якщо було змінено хоч один такий файл, базову систему буде перезібрано. Таке, зазвичай, трапляється, якщо у основній системі встановлюється або оновлюється якийсь пакунок (наприклад, за допомогою програм, подібних до \f(CW\*(C`yum\*(C'\fR або \f(CW\*(C`apt\-get\*(C'\fR). Причиною повторного збирання базової системи є забезпечення захисту: нова програма, яку було встановлено, може містити виправлення захисту, тому нам варто включити виправлену програму до базової системи автоматично.
.PP
Ось речі, які пов'язано із швидкодією:
.IP \(bu 4
Процес побудови (або повторної побудови) кешованої базової системи є повільним. Ви можете уникнути його, якщо скористаєтеся фіксованою базовою системою (див. нижче).
.IP \(bu 4
Якщо ви не користуєтеся фіксованою базовою системою, майте на увазі, що оновлення програмного забезпечення основної системи призведе до одноразового повторного збирання базової системи.
.IP \(bu 4
\&\fI/var/tmp\fR (або \f(CW$TMPDIR\fR, \f(CW$LIBGUESTFS_CACHEDIR\fR) має зберігатися на швидкому диску і мати достатньо місця для базової системи.
.SH "ВИКОРИСТАННЯ ФІКСОВАНОЇ БАЗОВОЇ СИСТЕМИ"
.IX Header "ВИКОРИСТАННЯ ФІКСОВАНОЇ БАЗОВОЇ СИСТЕМИ"
Щоб мати повний контроль над тим, коли збирається базова система, ви можете зібрати фіксовану базову систему. Ця базова система має зберігатися на швидкому локальному диску.
.PP
Щоб зібрати образ системи для розгортання, віддайте таку команду:
.PP
.Vb 1
\& libguestfs\-make\-fixed\-appliance <каталог>
.Ve
.PP
замінивши рядок \f(CW\*(C`<каталог>\*(C'\fR на назву каталогу, у якому зберігатиметься базова система (зазвичай, вам слід вказати підкаталог, наприклад: \fI/usr/local/lib/guestfs/appliance\fR або \fI/dev/shm/appliance\fR).
.PP
Далі, встановіть значення для \f(CW$LIBGUESTFS_PATH\fR (і переконайтеся, що цю змінну середовища встановлено у вашій програмі libguestfs) або внесіть зміни до вашої програми так, щоб вона викликала \f(CW\*(C`guestfs_set_path\*(C'\fR. Приклад:
.PP
.Vb 1
\& export LIBGUESTFS_PATH=/usr/local/lib/guestfs/appliance
.Ve
.PP
Тепер ви можете запускати програми libguestfs, засоби віртуалізації, guestfish тощо у звичний спосіб. Програми використовуватимуть вашу фіксовану базову систему і ніколи не збиратимуть, не перезбиратимуть і не кешуватимуть власну базову систему.
.PP
(Докладніші відомості з цієї теми можна знайти тут: \fBlibguestfs\-make\-fixed\-appliance\fR\|(1)).
.SS "Швидкодія фіксованої базової системи"
.IX Subsection "Швидкодія фіксованої базової системи"
Наші тестування показали, що використання фіксованої базової системи не дає ніяких помітних переваг у швидкодії, навіть якщо розташувати базову систему у оперативній пам'яті (тобто на пристрої \fI/dev/shm\fR). Втім, слід зважити ось на що:
.IP 1. 4
Використання фіксованої базової системи запобігатиме спробам libguestfs повторно зібрати базову систему, що означатиме, що тривалість запуску libguestfs буде легше передбачити.
.IP 2. 4
Базова система завантажується на вимогу. Простий тест, наприклад такий:
.Sp
.Vb 1
\& time guestfish \-a /dev/null run
.Ve
.Sp
не дуже навантажує базову систему. Справжня програма libguestfs, де використовуватимуться складні виклики програмного інтерфейсу, навантажуватиме базову систему набагато більше. Можливість зберігати базову систему у вказаному місці робить швидкодію значно передбачуванішою.
.SH "ЗМЕНШЕННЯ КІЛЬКОСТІ ЗАПУСКІВ БАЗОВОЇ СИСТЕМИ"
.IX Header "ЗМЕНШЕННЯ КІЛЬКОСТІ ЗАПУСКІВ БАЗОВОЇ СИСТЕМИ"
Набагато ефективнішим, але не завжди найпростішим способом дістати добру швидкодію є забезпечення якомога меншої кількості запусків базової системи. Це, ймовірно, включає внесення змін до самої вашої програми libguestfs.
.PP
Намагайтеся викликати \f(CW\*(C`guestfs_launch\*(C'\fR не більше одного разу на одну віртуальну машину або образ диска.
.PP
Замість використання окремого екземпляра \fBguestfish\fR\|(1) для внесення змін до тієї самої гостьової системи, скористайтеся єдиним екземпляром guestfish і/або використовуйте параметр guestfish \fI\-\-listen\fR.
.PP
Спробуйте написати вашу програму у формі фонової служби, яка підтримує зв'язок із гостьовою системою відкритим протягом усього сеансу внесення послідовності змін. Крім того, можете скерувати усі дії, які ви хочете виконати, до відкриття зв'язку із гостьовою системою.
.PP
Ви також можете спробувати додавати диски з декількох гостьових систем до єдиної базової системи. Перш ніж намагатися це зробити, врахуйте ось що:
.IP 1. 4
Додавання декількох гостьових системи до однієї базової системи створює проблему із захистом, оскільки може уможливити для однієї гостьової системи втручання до дисків іншої гостьової системи. Робіть це, лише якщо ви довіряєте усім гостьовим системам або якщо ви можете згрупувати гостьові системи за рівнем довіри.
.IP 2. 4
Існує жорстке обмеження для кількості дисків, які ви можете додати до однієї базової системи. Щоб отримати максимальне можливе значення, скористайтеся викликом "guestfs_max_disks" in \fBguestfs\fR\|(3). Докладнішу інформацію можна знайти у розділі "ОБМЕЖЕННЯ" in \fBguestfs\fR\|(3).
.IP 3. 4
Використання libguestfs у цей спосіб є ускладненим. Диски можуть взаємодіяти у несподіваний спосіб: наприклад, якщо у двох гостьових системах використовуються однакові UUID для файлової системи (оскільки ці системи було клоновано) або існують групи томів із однаковими назвами (але див. \f(CW\*(C`guestfs_lvm_set_filter\*(C'\fR).
.PP
\&\fBvirt\-df\fR\|(1), типово, додає одразу декілька дисків, тому код цієї програми є чудовим прикладом для ваших власних розробок.
.SH "СКОРОЧЕННЯ ЧАСУ, ПОТРІБНОГО ДЛЯ ІНСПЕКТУВАННЯ ВІРТУАЛЬНИХ МАШИН"
.IX Header "СКОРОЧЕННЯ ЧАСУ, ПОТРІБНОГО ДЛЯ ІНСПЕКТУВАННЯ ВІРТУАЛЬНИХ МАШИН"
Основна порада очевидна: не виконуйте інспектування (це дуже витратна операція), якщо вам не потрібні його результати.
.PP
Якщо гостьова система інспектується декілька разів, варто створити кеш результатів першого інспектування і повторно скористатися ними для наступних дій.
.PP
Деякі диски взагалі не потребують інспектування. Наприклад, якщо ви створюєте образ диска, або якщо образ диска не є віртуальною машиною, або якщо образ диска має заздалегідь відоме компонування.
.PP
Навіть якщо базове інспектування (\f(CW\*(C`guestfs_inspect_os\*(C'\fR) є обов'язковим, можна обійтися без допоміжних операцій з інспектування:
.IP \(bu 4
Монтування дисків є необхідним, лише якщо потрібно отримати докладніші дані щодо файлової системи.
.IP \(bu 4
Отримання списку програм (\f(CW\*(C`guestfs_inspect_list_applications\*(C'\fR) є витратною операцією для Linux, яка, втім, виконується дуже швидко для Windows.
.IP \(bu 4
Створення піктограми гостьової системи (\f(CW\*(C`guestfs_inspect_get_icon\*(C'\fR) виконується дуже швидко для Linux, але є витратною операцією для Windows.
.SH "ПАРАЛЕЛЬНІ БАЗОВІ СИСТЕМИ"
.IX Header "ПАРАЛЕЛЬНІ БАЗОВІ СИСТЕМИ"
Базові системи libguestfs є здебільшого зв'язками введення\-виведення даних, отже ви можете паралельно запускати одразу декілька базових систем.  Якщо у основній системі достатньо багато вільної оперативної пам'яті, між запуском 1 базової системи і паралельним запуском багатьох базових систем відмінність є незначною.
.PP
На 2\-ядерному (4 потоки обробки) ноутбуці із 16 ГБ оперативної пам'яті, використання (не дуже реалістичного) тестового скрипту мовою Perl, наведеного нижче, дало вказані нижче результати, які свідчать про чудову масштабованість у запуску 1 базової системи і паралельному запуску 20 базових систем:
.PP
.Vb 10
\&  12 ++\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-++
\&     +    +    +    +    +     +    +    +    +    +    *
\&     |                                                  |
\&     |                                               *  |
\&  11 ++                                                ++
\&     |                                                  |
\&     |                                                  |
\&     |                                          *  *    |
\&  10 ++                                                ++
\&     |                                        *         |
\&     |                                                  |
\& s   |                                                  |
\&   9 ++                                                ++
\& e   |                                                  |
\&     |                                     *            |
\& c   |                                                  |
\&   8 ++                                  *             ++
\& o   |                                *                 |
\&     |                                                  |
\& n 7 ++                                                ++
\&     |                              *                   |
\& d   |                           *                      |
\&     |                                                  |
\& s 6 ++                                                ++
\&     |                      *  *                        |
\&     |                   *                              |
\&     |                                                  |
\&   5 ++                                                ++
\&     |                                                  |
\&     |                 *                                |
\&     |            * *                                   |
\&   4 ++                                                ++
\&     |                                                  |
\&     |                                                  |
\&     +    *  * *    +    +     +    +    +    +    +    +
\&   3 ++\-*\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-++
\&     0    2    4    6    8     10   12   14   16   18   20
\&               кількість паралельних базових систем
.Ve
.PP
Можна запустити і набагато більше за 20 базових систем паралельно, але вам слід мати на увазі, що якщо ви використовуєте модуль обробки libvirt, типово, libvirt обмежує кількість з'єднань із клієнтами двадцятьма.
.PP
Для отримання даних, наведених на рисунку вище, було використано простий скрипт мовою Perl, наведений нижче. Втім, набагато більше відомостей з цього питання, зокрема досконаліші скрипти для тестування та графіки, можна знайти у наступних дописах у блогах:
.PP
http://rwmj.wordpress.com/2013/02/25/multiple\-libguestfs\-appliances\-in\-parallel\-part\-1/ http://rwmj.wordpress.com/2013/02/25/multiple\-libguestfs\-appliances\-in\-parallel\-part\-2/ http://rwmj.wordpress.com/2013/02/25/multiple\-libguestfs\-appliances\-in\-parallel\-part\-3/ http://rwmj.wordpress.com/2013/02/25/multiple\-libguestfs\-appliances\-in\-parallel\-part\-4/
.PP
.Vb 1
\& #!/usr/bin/env perl
\& 
\& use strict;
\& use threads;
\& use warnings;
\& use Sys::Guestfs;
\& use Time::HiRes qw(time);
\& 
\& sub test {
\&     my $g = Sys::Guestfs\->new;
\&     $g\->add_drive_ro ("/dev/null");
\&     $g\->launch ();
\&     
\&     # Тут можна виконати якісь завдання за допомогою libguestfs.
\&     
\&     $g\->close ();
\& }
\& 
\& # Отримати усе до кешу.
\& test (); test (); test ();
\& 
\& for my $nr_threads (1..20) {
\&     my $start_t = time ();
\&     my @threads;
\&     foreach (1..$nr_threads) {
\&         push @threads, threads\->create (\e&test)
\&     }
\&     foreach (@threads) {
\&         $_\->join ();
\&         if (my $err = $_\->error ()) {
\&             die "launch failed with $nr_threads threads: $err"
\&         }
\&     }
\&     my $end_t = time ();
\&     printf ("%d %.2f\en", $nr_threads, $end_t \- $start_t);
\& }
.Ve
.SH "БОРОТЬБА ІЗ ПРОБЛЕМАМИ ЗІ ШВИДКОДІЄЮ"
.IX Header "БОРОТЬБА ІЗ ПРОБЛЕМАМИ ЗІ ШВИДКОДІЄЮ"
.SS "Переконайтеся, що увімкнено апаратну віртуалізацію"
.IX Subsection "Переконайтеся, що увімкнено апаратну віртуалізацію"
Скористайтеся командою \fI/proc/cpuinfo\fR, щоб переконатися, що апаратна віртуалізація доступна. Зауважте, що, можливо, апаратну віртуалізацію слід увімкнути у BIOS.
.PP
Усередині віртуальних машин апаратна віртуалізація зазвичай недоступна, тому, щоб ви не робили, у віртуальній машині libguestfs працюватиме повільно. Наш досвід свідчить про те, що вкладена віртуалізація працює погано, і, напевне, альтернативи запуску libguestfs у основній системі немає.
.SS "Переконайтеся, що KVM є доступним"
.IX Subsection "Переконайтеся, що KVM є доступним"
Переконайтеся, що KVM увімкнено і доступний користувачеві, який запускає libguestfs. Безпечним є встановлення прав доступу 0666 для \fI/dev/kvm\fR, як це робиться у більшості сучасних дистрибутивів.
.SS "Процесори, яких слід уникати"
.IX Subsection "Процесори, яких слід уникати"
Не використовуйте процесори, у яких немає апаратної віртуалізації, та процесорів, які просто дуже повільні (чудовим прикладом такого процесора є AMD Geode).
.SS "Xen dom0"
.IX Subsection "Xen dom0"
У Xen dom0 є віртуальною машиною, отже на ньому апаратна віртуалізація недоступна.
.SS "Скористайтеся libguestfs ≥ 1.34 і qemu ≥ 2.7"
.IX Subsection "Скористайтеся libguestfs ≥ 1.34 і qemu ≥ 2.7"
Під час циклу розробки libguestfs 1.33 ми приділяли багато часу швидкодії, зосередившись на швидкості завантаження, і додали декілька латок до libguestfs, qemu та Linux, що у певних випадках зменшило час завантаження до значень, менших за 1 секунду. Тому, ви можете спостерігати набагато швидшу роботу версій libguestfs та qemu, згаданих у заголовку розділу.
.SH "ДОКЛАДНИЙ АНАЛІЗ"
.IX Header "ДОКЛАДНИЙ АНАЛІЗ"
.SS "Аналіз завантаження"
.IX Subsection "Аналіз завантаження"
У https://github.com/libguestfs/libguestfs\-analysis\-tools можна знайти програму, яка називається \f(CW\*(C`boot\-analysis\*(C'\fR. Ця програма може виводити дуже докладні дані щодо кроків завантаження (наприклад, qemu, BIOS, ядра, скрипту ініціалізації libguestfs) і вимірювати тривалість виконання кожного з кроків.
.SS "Докладний таймінг з використанням ts"
.IX Subsection "Докладний таймінг з використанням ts"
Скористайтеся програмою \fBts\fR\|(1) (з moreutils), щоб переглянути докладну картину:
.PP
.Vb 10
\& $ guestfish \-a /dev/null run \-v |& ts \-i \*(Aq%.s\*(Aq
\& 0.000022 libguestfs: launch: program=guestfish
\& 0.000134 libguestfs: launch: version=1.29.31fedora=23,release=2.fc23,libvirt
\& 0.000044 libguestfs: launch: backend registered: unix
\& 0.000035 libguestfs: launch: backend registered: uml
\& 0.000035 libguestfs: launch: backend registered: libvirt
\& 0.000032 libguestfs: launch: backend registered: direct
\& 0.000030 libguestfs: launch: backend=libvirt
\& 0.000031 libguestfs: launch: tmpdir=/tmp/libguestfsw18rBQ
\& 0.000029 libguestfs: launch: umask=0002
\& 0.000031 libguestfs: launch: euid=1000
\& 0.000030 libguestfs: libvirt version = 1002012 (1.2.12)
\& [etc]
.Ve
.PP
Часові позначки вказано у секундах (з нарощуванням щодо попереднього рядка).
.SS "Докладна діагностика з використанням gdb"
.IX Subsection "Докладна діагностика з використанням gdb"
Ви можете керувати BIOS або ядром базової системи за допомогою gdb. Якщо ви добре знаєтеся на процесі діагностики за допомогою gdb, це може бути корисним інструментом для виявлення і усування регресій у процесі завантаження.
.PP
По\-перше, вам слід змінити qemu так, щоб програма запускалася із параметрами \f(CW\*(C`\-S\*(C'\fR і \f(CW\*(C`\-s\*(C'\fR. Ці параметри наказують qemu призупинити процес завантаження і уможливити долучення до нього засобу діагностики. Щоб дізнатися більше, ознайомтеся із підручником щодо \fBqemu\fR\|(1). Libguestfs викликає qemu декілька разів (для сканування допоміжних виведених даних тощо). Вам потрібен лише кінцевий виклик qemu, тому скористайтеся скриптом\-обгорткою, подібним до такого:
.PP
.Vb 1
\& #!/bin/bash \-
\& 
\& # Встановіть значення, яке вказуватиме на справжній виконуваний файл qemu.
\& qemu=/usr/bin/qemu\-kvm
\& 
\& if [ "$1" != "\-global" ]; then
\&     # Scanning help output etc.
\&     exec $qemu "$@"
\& else 
\&     # Really running qemu.
\&     exec $qemu \-S \-s "$@"
\& fi
.Ve
.PP
Далі, запустіть guestfish або інший інструмент libguestfs із обгорткою qemu (див. "ОБГОРТКИ QEMU" in \fBguestfs\fR\|(3), щоб зрозуміти, які дії виконуються):
.PP
.Vb 1
\& LIBGUESTFS_HV=/шлях/до/qemu\-wrapper guestfish \-a /dev/null \-v run
.Ve
.PP
Виконання має призупинитися після запуску qemu. У іншому вікні з'єднайтеся із qemu за допомогою gdb:
.PP
.Vb 7
\& $ gdb
\& (gdb) set architecture i8086
\& The target architecture is assumed to be i8086
\& (gdb) target remote :1234
\& Remote debugging using :1234
\& 0x0000fff0 in ?? ()
\& (gdb) cont
.Ve
.PP
Після цього ви можете використовувати стандартні методики gdb, наприклад, натискати \f(CW\*(C`^C\*(C'\fR, щоб перервати завантаження, або \f(CW\*(C`bt\*(C'\fR, щоб отримати трасування стека, встановлювати точки зупину тощо. Зауважте, що після проходження BIOS і потрапляння до ядра Linux вам варто знову змінити архітектуру на 32 або 64\-бітову.
.SH "ПРОБЛЕМИ ЗІ ШВИДКОДІЄЮ У ІНШИХ ПРОГРАМАХ"
.IX Header "ПРОБЛЕМИ ЗІ ШВИДКОДІЄЮ У ІНШИХ ПРОГРАМАХ"
Іноді регресії у швидкодії трапляються у інших програмах (наприклад, у qemu або ядрі системи), що спричиняє проблеми і у libguestfs.
.PP
У https://github.com/libguestfs/libguestfs\-analysis\-tools \fIboot\-benchmark/boot\-benchmark\-range.pl\fR є скриптом, яким можна скористатися для вимірювання параметрів роботи libguestfs на діапазоні внесків git у іншому проєкті, щоб визначити внесок, який спричинив уповільнення роботи (або її пришвидшення).
.PP
Щоб дізнатися більше про те, як користуватися цим скриптом, зверніться до підручника:
.PP
.Vb 1
\& ./boot\-benchmark/boot\-benchmark\-range.pl \-\-man
.Ve
.SH "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
.IX Header "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
\&\fBsupermin\fR\|(1), \fBguestfish\fR\|(1), \fBguestfs\fR\|(3), \fBguestfs\-examples\fR\|(3), \fBguestfs\-internals\fR\|(1), \fBlibguestfs\-make\-fixed\-appliance\fR\|(1), \fBstap\fR\|(1), \fBqemu\fR\|(1), \fBgdb\fR\|(1), http://libguestfs.org/.
.SH АВТОРИ
.IX Header "АВТОРИ"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "АВТОРСЬКІ ПРАВА"
.IX Header "АВТОРСЬКІ ПРАВА"
Copyright (C) 2012\-2023 Red Hat Inc.
.SH LICENSE
.IX Header "LICENSE"
.SH BUGS
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP \(bu 4
The version of libguestfs.
.IP \(bu 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP \(bu 4
Describe the bug accurately and give a way to reproduce it.
.IP \(bu 4
Run \fBlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
